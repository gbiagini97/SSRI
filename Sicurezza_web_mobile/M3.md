# Comunicazione sicura: i protocolli crittografici

## Definizione del contesto

### Comunicazione sicura lungo un canale insicuro

Indichiamo con la parola **canale** il mezzo tramite il quale due entita' possono comunicare.
Quando il canale e' accessibile anche ad altre entita', oltre a quelle che vogliono comunicare tra di loro, allora il canale si dice **insicuro**.
Poiche' internet e' un canale diviso tra moltissimi utenti, e' definitivamente un canale insicuro.

Nella comunicazione tra persone, browser/server, online banking client/server, router, e' necessario che le informazioni scambiate tra le due entita' siano **protette** e che queste identita' siano **autenticate** per verificarne l'identita'.

#### Comunicazione sicura
Per fare in modo che una comunicazione sia sicura, attraverso un canale insicuro come Internet dobbiamo stabilire delle proprieta' di sicurezza che devono essere garantite durante la comunicazione:
* **Confidenzialita'**: solo Alice e Bob devono poter "capire" il contenuto dei messaggi;
* **Integrita'**: i messaggi non devono venire modificati;
* **Autenticazione**: Alice e Bob devono essere sicuri che il loro interlocutore sia effettivamente chi dice di essere (e che loro si aspettano);
* **Non-repudiation**: Alice non puo' negare di aver spedito un messaggio a Bob.

#### Autenticazione nella rete
Quando si effettuano comunicazioni nella rete e' necessario specificare cosa si intenda autenticare.

##### Entity Authentication
Garantisce l'identita' dell'utente che in tempo reale sta comunicando all'interno di una specifica sessione di protocollo.

##### Message Authentication
Garantisce che il messaggio ricevuto proviene dalla sorgente indicata, senza dare alcuna indicazione di quando il messaggio sia stato effettivamente creato.

___

### Tipologia di attaccante

L'attaccante (Trudy) e' un **host malevolo** connesso ad Internet che puo' voler modificare il normale comportamento dei protocolli per scopi illeciti.

#### Protocolli TCP/IP
Alice e Bob sono due entita' che utilizzano Internet come canale di comunicazione, quindi usano i protocolli dello stack TCP/IP.

| n 	| Internet          	| ISO/OSI 7 layer model 	| n 	|
|---	|-------------------	|-----------------------	|---	|
|   	|                   	| Application           	| 7 	|
| 5 	| Application       	| Presentation          	| 6 	|
|   	|                   	| Session               	| 5 	|
| 4 	| TCP               	| Transport             	| 4 	|
| 3 	| IP                	| Network               	| 3 	|
| 2 	| Network Interface 	| Data Link>            	| 2 	|
| 1 	| Hardware          	| Physical              	| 1 	|

>I protocolli di comunicazione definiscono il formato, l'ordine dei messaggi spediti e ricevuti tra le entita' della rete, e le azioni intraprese dopo la trasmissione/ricezione

#### Cosa puo' fare un attaccante
In genere un attaccante puo' essere definito **attivo/passivo** a seconda di cosa puo' fare lungo un canale di comunicazione.
Rimanendo in ascolto lungo il canale puo' intercettare il messaggio (minacciando la confidenzialita') per poi:
* Leggere solamente il messaggio (passivo);
* Effettuare azioni sul messaggio (attivo):
  * Cancellare il messaggio senza inoltrarlo al destinatario;
  * Modificare i messaggi in transito (minaccia all'integrita');
  * Puo' spedire messaggi arbitrari (minaccia all'autenticazione);
  * Puo' riutilizzare vecchi messaggi salvati, tramite un **replay attack** (minaccia all'autenticazione).

#### Contromisure
Per impedire a Trudy di modificare il funzionamento del protocollo, e' necessario crittografare il messaggio (tramite delle **primitive crittografiche**) per continuare a garantire la confidenzialita' e fare in modo che solo Alice e Bob lo possano decifrare.

La segretezza puo' pero' non essere sufficiente per garantire anche l'autenticazione e l'integrita'.

Per fare in modo che un protocollo sia del tutto sicuro, e dunque vengano garantite tutte le proprieta' di sicurezza, sara' necessario usare una combinazione di primitive crittografiche e costruire un **protocollo di sicurezza**.

___

## Introduzione alla crittografia

### Storia della crittografia

___

### Proprieta' degli algoritmi di cifratura

Alice vuole mandare un messaggio m a Bob, mentre Trudy e' l'attaccante passivo (puo' leggere il messaggio M):
* Alice da in input all'**algoritmo di codifica** la chiave di codifica insieme al messaggio in chiaro, ottenendo il messaggio cifrato;
* Alice spedisce il messaggio cifrato a Bob attraverso il canale;
* Bob applica l'**algoritmo di decodifica** con la chiave di decodifica insieme messaggio cifrato, ottenendo il messaggio in chiaro.

#### Principio di Kerchoff
La proprieta' di un buon algoritmo di cifratura/decifratura e' sintetizzata dal **principio di Kerchoff**:
> La sicurezza e' data dalla robustezza dell'algoritmo e dalla segretezza della chiave, non della segretezza dell'algoritmo.

Per questo, nel caso precedente, Trudy puo' avere accesso al canale, dunque ai messaggi, ed essere a conoscenza dell'algoritmo di cifratura, in quanto la sicurezza e' garantita dal possesso delle chiavi di cifratura/decifratura.

In particolare valgono le seguenti affermazioni:
* **E**: funzione codifica;
* **D**: funzione decodifica;
* **m**: messaggio;
* **x**: messaggio cifrato;
* **K**: chiave per la cifratura;
* **K'**: chiave per la decifratura.

> D<sub>K'</sub>(E<sub>K</sub>(m)) == m

> E<sub>K</sub>(m) e' semplice da calcolare, dati m e K

> D<sub>K'</sub>(x) e' semplice da calcolare, dati x e K', ma per Trudy deve essere molto difficile da calcolare (in quanto non possiede K')

> Se x == E<sub>K</sub>(m), e' difficile trovare m senza K

#### Lunghezza delle chiavi
Per quanto possa essere valido un algoritmo crittografico, esso puo' essere forzato provando a decifrare il messaggio con tutte le chiavi possibili tramite un attacco bruteforce.

Per questo motivo, il numero delle chiavi possibili deve essere grande a sufficienza per rendere computazionalmente impossibile questo attacco.
Se scelgo una chiave di *n* bit, lo spazio delle chiavi sara' 2<sup>n</sup>.

#### Gestione di messaggi molto lunghi

##### Block ciphers
Algoritmo che suffivide il messaggio in blocchi di lunghezza predefinita e li cifra/decifra uno alla volta con la stessa chiave (aggiungendo dei bit finali all'ultimo blocco). Tipicamente un blocco e' di 64 bit.

##### Stream ciphers
Algoritmo che cifra il messaggio 1 bit o 1 byte alla volta usando una sequenza denominata **keystream** generata randomicamente a partire dalla chiave o dal messaggio.
___

### Crittografia a chiave simmetrica e asimmetrica

#### Crittografia simmetrica
Se si utilizza la stessa chiave per la codifica e la decodifica allora si tratta di crittografia a chiave simmetrica o a chiave segreta: infatti la segretezza e l'integrita' sono garantite proprio da quest'ultima.

Se Trudy venisse a conoscenza della chiave segreta, potrebbe:
* Produrre nuovi messaggi a nome di Alice o di Bob;
* Leggere tutti i messaggi trasmessi;

Le implementazioni di algoritmi per la crittografia simmetrica sono in genere molto veloci (esistono **implementazioni hardware**) e usano chiavi relativamente corte (64-256 bit), inoltre possono essere utilizzati per la generazione di numeri casuali.

Gli svantaggi sono legati alla gestione e la distribuzione delle chiavi, in quanto:
* La chiave deve essere segreta, e rimanere tale;
* E' necessario che le parti che devono comunicare condividano a priori la chiave segreta da utilizzare per la comunicazione;
* Per evitare gli attacchi bruteforce e' utile cambiare spesso la chiave riproducendo pero' il problema della distribuzione.

La crittografia simmetrica viene utilizzata in diversi ambiti e con diversi obiettivi, in particolare per garantire confidenzialita' e integrita' con il problema di dover **scambiare prima la chiave lungo un canale sicuro**.
Viene usata anche per la memorizzazione sicura su media insicuri (filesystem criptati) e per l'autenticazione con protocollo challenge-response.

##### Gestione delle chiavi
Nel caso in cui ci siano *n* utenti che vogliono parlare tra di loro in modo sicuro,ciascuna coppia di utenti ha bisogno di una chiave il che porta ad un numero polinomiale (n(n-1)/2) di chiavi che si devono scambiare in modo sicuro mediante:
* Scambio fisico;
* Canale sicuro.
Poiche' non e' certo che tutti gli *n* utenti parlino tra di loro, l'algoritmo e' inefficiente.

###### KDC - Key Distribution Center
Il Key Distribution Center e' da considerarsi la *n+1*esima **parte fidata** in un gruppo di *n* utenti, e si occupa di **generare le chiavi** per ogni coppia che le richiede (questo presuppone che gli utenti debbano condividere a priori una chiave con il KDC, per un totale di *n* chiavi totali iniziali).
Con la tecnica del KDC si ha un algoritmo piu' efficiente in quanto il numero di chiavi da scambiare inizialmente non e' polinomiale al numero di utenti totali.

I problemi sono:
* Il KDC deve essere fidato;
* Il KDC diventa un collo di bottiglia e unico punto di fallimento;
* Distribuire inizialmente le chiavi tra gli *n* utenti e il KDC.

Se l'utente U<sub>1</sub> vuole parlare con l'utente U<sub>2</sub>:
* U<sub>1</sub> -> KDC: "Collegami a U<sub>2</sub>";
* KDC genera la nuova chiave K<sub>1-2</sub>;
* KDC -> U<sub>1</sub>: E<sub>K<sub>1</sub></sub>(K<sub>1-2</sub>);
* KDC -> U<sub>2</sub>: E<sub>K<sub>2</sub></sub>(K<sub>1-2</sub>, "U<sub>1</sub> vuole parlare con te").

##### Algoritmi a chiave simmetrica famosi
* DES - Data Encryption Standard;
  * Triple DES (3DES);
* DES-X;
* AES - Advanced Encryption Standard;
* IDEA - International Data Encryption Algorithm;
* RC2;

#### Crittografia asimmetrica
La crittografia asimmetrica (detta anche crittografia a chiave pubblica) utilizza invece due chiavi, una per la codifica, l'altra perl a decodifica.

Ogni utente ha una coppia di chiavi, dunque non e' necessario lo scambio di chiavi iniziale:
* Chiave pubblica: informazione da diffondere;
* Chiave segreta: segreto da custorire.

Tramite la crittografia asimmetrica:
* La segretezza del messaggio e' garantita;
* Sono necessarie meno chiavi, ma e' importante garantire l'autenticita' delle chiavi pubbliche;
* E' possibile garantire integrita' e autenticazione procedendo al contrario (crittando con la propria privata), ma in questo modo la segretezza non e' piu' garantita in quanto chiunque possieda la chiave pubblica puo' leggere.

Tendenzialmente la crittografia asimmetrica, rispetto a quella simmetrica, e' piu' lenta e usa chiavi piu' lunghe (1024-2048 bit), qunidi inefficienti per messaggi lunghi.

>La best practice prevede l'utilizzo di chiavi asimmetriche per lo scambio di chiavi simmetriche.


##### Algoritmi a chiave asimmetrica famosi
* RSA
* Crittosistema di Rabin
* ElGamal

___

### Funzioni hash

La funzione hash e' una funzione computazionalmente efficiente che mappa stringhe binarie di lunghezza arbitraria in stringhe di lunghezza costante dette **hash value** (o **message digest**, **checksum**, **one-way function**):
> h: {0,1}<sup>\*</sup> -> {0,1}<sup>n</sup>

Per definizione deve avere le seguenti proprieta':
* **Computazionalmente efficiente**, dunque semplice da calcolare:
  * Dato *x*, e' facile da calcolare *h(x)*;
* In grado di effettuare **compressione**:
  * *h* mappa input di lunghezza arbitraria ad output *h(x)* di lunghezza *n* definita;
* **Collision resistant**:
  * Difficile trovare *m* e *m'* tali che *h(m)=h(m')*;
* **Irreversibile** (one-way):
  * **Preimage resistance**: dato *y* e' difficile trovare *x*, tali che *y=h(x)*;
  * **Second preimage resistance**: dato *m* e' difficile trovare *m'*, tali che *h(m)=h(m')*;
* **Effetto valanga**:
  * Una piccola modifica al valore di *m* deve alterare tutto *h(m)*.

#### Paradosso del compleanno
La probabilita' che in un gruppo di *n* persone ne esistano almeno 2 che sono ante nello stesso giorno aumenta velocemente con *n*, piu' di quanto potrebbe dire l'intuito.

Lo stesso paradosso si puo' applicare alla probabilita' di collisione nelle funzioni di hash, che dipende dalla lunghezza *n* del valore di hash:
* Sia *y* un hash lungo *n* bit, il numero di tentativi per trovare un *x* tale che *h(x)=y* e' di 2<sup>n-1</sup>;
* Dato un insieme di hash value lunghi *n* bit, un insieme di almeno 2<sup>n/2</sup> input ha un'alta probabilita' di contenere una coppia che causi collisione.

#### Utilizzi
##### Password hashing
Non si memorizzano le password in chiaro, ma l'hash delle password (preferibilmente concatenate con il salt, come accade nei sistemi Unix).
Sono comunque possibili attacchi offline nel caso si abbia a disposizione il database.

##### Message digesting
Le funzioni hash vengono usate anche per accorciare messaggi lunghi, in particolare nei contesti della firma digitale con chiave asimmetrica e della sincronizzazione dei file via rete (rsync).

Nell'ambito dei protocolli crittografici risulta particolarmente utile in quanto ha un effetto collaterale positivo: unisce e fonde insieme le parti del messaggio che viene dato in input alla funzione di hash.

##### Garantire integrita' dei dati
Si suppone si voglia proteggere un dato *x*, si calcola il suo hash *h(x)* e si archivia in un luogo protetto.
In seguito, per vedere se il dato *x* e' stato modificato, si calcola nuovamente il suo valore di hash e lo si confronta con il valore precedentemente calcolato.

Questo metodo e' utilizzato per verificare l'integrita' dei file negli HIDS (Host-based Intrusion Detection Systems) e per verificare l'integrita' dei file scaricati dalla rete.

L'unico problema di questo approccio e' che devo fare affidamento ad un sistema di archiviazione, e nel caso in cui questo abbia una falla e l'attaccante possa modificare il valore archiviato, allora l'attaccante e' in grado di inserire *h(x')* (modificato), al posto di *h(x)*.

#### MAC - Message Authentication Code
Si tratta di funzioni hash con chiave, che oltre a prendere in input una stringa di lunghezza arbitraria, prende anche una **chiave segreta condivisa**:
> h<sub>k</sub>: {0,1}<sup>\*</sup> -> {0,1}<sup>n</sup>

In questo caso la funzione deve soddisfare una proprieta' addizionale detta **computation resistance**: 
> Per ogni possibile chiave *k* non nota all'avversario e un insieme di valori di stringhe di input, con il rispettivo valore di hash *(x<sub>i</sub>, h<sub>k</sub>(x<sub>i</sub>))*, deve essere computazionalmente impossibile calcolare l'hash di input diversi *h<sub>k</sub>(x)* per ogni nuovo input *x*.

La computation resistance garantisce integrita' e autenticazione (**data origin**) del messaggio.

Il MAC non garantisce segretezza (in quanto non viene spedito anche il messaggio in chiaro, di modo che il destinatario ricalcoli il MAC) o non-repudiation (anche se Bob sapesse che solo Alice potrebbe aver calcolato il MAC del messaggio ricevuto, Bob non e' in grado di dimostrare che puo' non essere stato lui a calcolare l'hash con chiave).
Inoltre non puo' essere verificato da una terza parte (solo chi possiede la chiave segreta condivisa).

##### Utilizzi
Anche il MAC serve a verificare l'integrita' dei dati:
* Il mittente spedisce il messaggio *m* e il MAC *h<sub>k</sub>(m)*;
* Il destinatario riceve entrambe le parti, e a partire da *m* ricalcola il MAC *h<sub>k</sub>(m)*;
* Se il messaggio calcolato corrisponde a quello ricevuto, il messaggio non e' stato modificato.

Nel filesystem, per garantire l'integrita' dei file, oltre al file *file.pdf*, si archivia anche *h<sub>pwd_utente</sub>(file.pdf)*. In questo modo, l'utente che ha generato il file, e' l'unico in grado di modificarlo perche' e' l'unico a conoscere la chiave che aggiorna l'hash memorizzato.

#### Funzioni hash famose
* MD4: a 128 bit, e' diventata obsoleta in quanto nel 1996 e' stata trovata una collisione;
* MD5: a 128 bit, e' molto diffusa anche per i protocolli di rete, ma esistono algoritmi efficienti in grado di generare stringhe che collidono;
* SHA: famiglia di 5 diverse funzioni (Secure Hash) la cui piu' diffusa e' la SHA-1 a 160 bit;
* RIPEMD: alternativa europea a MD4 e MD5.

___

### Firma digitale

La firma digitale e' l'analogo della firma su carta, ma nel cyberspazio.

#### Caratteristiche
* Deve essere facilmente prodotta dal legittimo proprietario;
* Nessun utente deve poter riprodurre la firma di altri;
* Chiunque deve poter facilmente verificare una firma;
* La firma non deve essere utilizzabile su un altro documento.

#### Proprieta' di sicurezza da garantire
Le proprieta' di sicurezza che si vogliono garantire sono:
* Integrita': il messaggio, una volta firmato, non deve poter essere alterato;
* Autenticazione: il mittente ha sottoscritto il contenuto del messaggio;
* Non-ripudio: il firmatario non puo' rinnegare la paternita' del messaggio;

La funzione hash con chiave (MAC) garantisce sia integrita' che autenticazione del messaggio, ma non e' sufficiente in quanto non garantisce il non ripudio:
Bob puo' creare un MAC(m) esattamente come Alice, quindi, anche se Bob sa che Alice e' l'autrice del messaggio, non puo' mostrarlo come prova a nessuno.

**Solo chi possiede la chiave segreta condivisa puo' verificare la firma**, non chiunque.

#### Creazione della firma
La firma digitale si ottiene basandosi sulla crittografia asimmetrica:
* La firma si ottiene **cifrando con la chiave privata**;
* La verifica della firma si ottiene **decifrando con la chiave pubblica**.

Quindi:
* Chiunque puo' verificare un messaggio firmato da Alice (se ne possiede la chiave pubblica);
* Solo Alice puo' spedire messaggi firmati;
* Non ripudio: Bob non puo' creare la firma di Alice perche' non conosce la sua chiave privata.

Le primitive crittografiche a chiave asimmetrica sono particolarmente inefficienti, per questo, invece di creare la firma sul messaggio in chiaro, viene fatta sul digest:
 * Calcolo del message digest del messaggio;
 * Cifratura del digest con chiave privata (si ottiene la firma digitale del messaggio);
 * Invio della firma digitale e del messaggio in chiaro.

#### Verifica della firma
Il destinatario che riceve un messaggio che continene una firma:
* Separa il messaggio in chiaro e la firma;
* Decodifica la firma con la chiave pubblica del mittente ed ottiene il digest del messaggio ricevuto;
* Calcola il digest sul messaggio in chiaro;
* Confronta il digest appena calcolato col digest ricevuto:
  * Se coincidono allora la firma e' valida ed il messaggio e' integro;
  * Altrimenti il testo e' stato alterato, dunque si rifiuta il messaggio.

#### Resistenza alla contraffazione
> Sia *Firma(K<sup>-1</sup>, m)* la funzione che firma il messaggio *m* e *Verifica(K, x, m)* la funzione di verifica (con *x=Firma(K<sup>-1</sup>, m)*) allora:
> * **Non si riesce a calcolare** *Firma(K<sup>-1</sup>, m)* da *m* e *K*;
> * **Resiste all'attacco di forza bruta**: data *K*, non si riesce a produrre *Firma(K<sup>-1</sup>, m)* per nessun *m*.

#### Problema dell'identita'
Basandosi sulla crittografia asimmetrica, rimane il problema dell'associazione identita'-chiave pubblica: l'utilizzo della firma digitale garantisce che un messaggio e' stato firmato con una determinata chiave privata: pero' **non dice nulla sull'autore della firma** se non si e' a conoscenza in modo certo della chiave pubblica della persona.

E' necessario un modo sicuro di scambiarsi le chiavi pubbliche, garantendo (non tanto la confidenzialita') l'autenticazione. Puo' essere fatto di persona o tramite una terza parte fidata come una **Certification Authority**.

#### Hashing vs MAC vs Firme Digitali

##### Hashing (*digest* privato)
* Produce il *digest* di un messaggio;
* Per garantire integrita' deve venire memorizzato separatamente dal messaggio.

##### MAC (*digest* cifrato)
* Il *digest* viene protetto da una chiave condivisa e una segreta;
* Puo' venire trasmesso lungo un canale pubblico.

##### Firma digitale (non-repudiation)
* Il *digest* viene cifrato da una chiave privata: integrita', non ripudio e data origin authentication, non confidenzialita';
* Non ci sono dati segreti condivisi con chi verifica e chi firma.

___

### Certificato digitale