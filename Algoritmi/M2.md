# Organizzazione dati di tipo lineare

## Liste

### Liste

Definizione:
> Una lista e' una sequenza di elementi dello stesso tipo, dove e' sempre possibile aggiungere o togliere elementi.

Le caratteristiche della lista sono:
* L'accesso solo al primo o all'ultimo elemento;
* L'accesso tramite scansione agli altri elementi.

Specifica sintattica:
* Tipi di dato:
  * Lista _L_;
  * Elementi della lista _a<sub>i</sub>_ di tipo _tipoelem_;
  * Posizioni relative di _a<sub>i</sub>_ e _a<sub>j</sub>_ tramite gli indici _p_ e _q_;
  * Booleano _b_;
  * Lista vuota Λ.
* Operatori specifici del tipo di dato lista:
* crealista: `() -> lista`;
  * listavuota: `(lista) -> booleano`;
  * primolista: `(lista) -> posizione`;
  * ultimolista: `(lista) -> posizione`;
  * succlista: `(posizione, lista) -> posizione`;
  * predlista: `(posizione, lista) -> posizione`;
  * finelista: `(posizione, lista) -> posizione`;
  * leggilista: `(posizione, lista) -> tipoelem`;
  * scrivilista: `(tipoelem, posizione, lista) -> lista`;
  * inslista: `(tipoelem, posizione, lista) -> lista`;
  * canclista: `(posizione, lista) -> lista`.

Specifica semantica:
* `crealista() = L'`
  * post: _L' = Λ_
* `listavuota(L) = b`
  * post: vero solo se _L = Λ_
* `primolista(L) = p`
  * post: _p = posizione<sub>1</sub>_
* `ultimolista(L) = p`
  * post: _p = posizione<sub>n</sub>_
* `succlista(p, L) = q`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _1<=i<=n_
  * post: _q = pos<sub>i+1</sub>_
* `predlista(p, L) = q`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _1<=i<=n_
  * post: _q = pos<sub>i-1</sub>_
* `finelista(p, L) = b`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _0<=i<=n+1_
  * post: _b_ vero solo se _p = pos<sub>0</sub> o pos<sub>n+1</sub>_
* `leggilista(p, L) = a`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _1<=i<=n_
  * post: _a = a<sub>i</sub>_
* `scrivilista(a, p, L) = L'`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _1<=i<=n_
  * post: _L' = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>i-1</sub>, a, a<sub>i+1</sub>, ..., a<sub>n</sub>_
* `inslista(a, p, L) = L'`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _0<=i<=n+1_
  * post: 
    * _L' = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>i-1</sub>, a, a<sub>i+1</sub>, ..., a<sub>n</sub>_ se _1<=i<=n_;
    * _L' = a<sub>1</sub>, ..., a<sub>n</sub>, a_ se _i = n + i_;
    * _L' = a, a<sub>1</sub>, ..., a<sub>n</sub>_ se _i = 0_
* `canclista(p, L) = L'`
  * pre: _L = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>_; _p = pos<sub>i</sub>_, _1<=i<=n_
  * post:_L' = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>i-1</sub>, a, a<sub>i+1</sub>, ..., a<sub>n</sub>_

Realizzazione con i puntatori:
* Memorizzare gli _n_ elementi in _n_ record, detti **celle** tali che l'_i_-esima cella contiene l'_i_-esimo elemento della lista e l'indirizzo (puntatore) della cella contenente l'elemento successivo;
* La prima cella e' indirizzata da una variabile **_L_** di tipo puntatore, mentre l'ultima cella contiene un valore convenzionale **_null_**.

Estensioni:
* **Sentinella**: cella aggiuntiva per gli estemi;
* **Bidirezionalita'**: ogni cella punta alla successiva e alla precedente;
* **Circolarita'**: l'ultima cella punta direttamente alla prima.

![M2_implementazioni_lista](md_resources/M2_implementazioni_lista.png)

![M2_implementazione_lista1](md_resources/M2_implementazione_lista1.png)


#### Cursori
Quando i puntatori non vengono forniti dal linguaggio di programmazione e' possibile realizzare una lista utilizzando un cursore:
> Un cursore e' una variabile intera il cui valore e' l'indice di un vettore che simula la memoria disponibile per i puntatori ->. Un cursore emula un puntatore.

In memoria, un vettore chiamato **spazio**:
* Contiene tutte le liste, ciascuna individuata da un proprio cursore iniziale;
* Contiene tutte le celle libere, organizzate anch'esse in una lista, detta **listalibera**.

![M2_lista_bidirezionale_sentinella_cursori](md_resources/M2_lista_bidirezionale_sentinella_cursori.png)

### Programmare con le liste
Problema: il rango di un elemento di una lista e' definito come la somma del suo valore e dei valori degli elementi che lo seguono. Scrivere una procedura che data la lista iniziale **_L_** di interi produce una lista **_R_** dove il valore contenuto in ogni cella corrisponde al rango di **_L_**. Analizzare la complessita' dell'algoritmo proposto.

Formalizzazione del concetto di rango:
> Sia _a<sub>i</sub>_ l'elemento di _L_ in posizione _i_, _1<=i<=n. Allora la funzione che misura il rango puo' essere scritta come segue:

![M2_rango_lista](md_resources/M2_rango_lista.png)

La formula ci suggerisce di scansionare la lista _L_ dall'ultima posizione mantenendo in una variabile la somma degli elementi scanditi. Ogni volta si va ad inserire il valore corrente come elemento della lista _R_.

#### Complessita' del problema
Secondo i metodi:
* Dimensione dell'input:
  * E' necessario scansionare l'intera lista _L_ che ha dimensione _n_, dunque la complessita' risulta _Ω(n)_;
* Eventi contabili:
  * Sono necessarie _n-1_ somme per calcolare il rango di ogni elemento, quindi la complessita' risulta _Ω(n)_.

#### Algoritmo iterativo

```C
void rango_i(lista L, lista R) {
    posizione p = ultimolista(L);
    int a = leggilista(p, L);

    crealista(R);
    inslista(a, primolista(R), R);
    p = predlista(p, L);

    while(!finelista(p, L)) {
        a += leggilista(p, L);
        inslista(a, primolista(R), R);
        p = predlista(p, L);
    }
}
```

La complessita' e' dominata dal ciclo `while` dove vengono utilizzati 5 operatori su lista.
Sapendo che tali operatori costano _O(1)_ possiamo dire che l'algoritmo `rango_i` ha complessita' _O(n)_.

#### Algoritmo ricorsivo

```C
void rango_r(posizione p, lista L) {
    int a = 0;

    if(finelista(succlista(p, L), L)) {
        a = leggilista(p, L);
    } else {
        a = rango_r(succlista(p, L), L);
        a += leggilista(p, L);
    }
    return(a);
}
```

Relazione di ricorrenza _T(n)_:
![M2_relazione_ricorrenza_liste](md_resources/M2_relazione_ricorrenza_liste.png)

Per sostituzione otteniamo che:
_T(n)_ = _T(n-1) + c_

_T(n)_ = _T(n-2) + 2c_

_T(n)_ = _T(n-3) + 3c_

_T(n)_ = ...

_T(n)_ = _T(n - (n-1)) + (n-1)c_

_T(n) = _T(1) + (n-1)c_

_T(n) = _d + (n-1)c_

_T(n) = _cn + (d-c)_

_T(n)_ => _O(n)_

#### Conclusioni

Risulta che:
* La complessita' del problema e' _Ω(n)_
* La complessita' `rango_i` e' _O(n)_
* La complessita' `rango_r` e' _O(n)_

Dunque entrambi gli algoritmi sono ottimi.