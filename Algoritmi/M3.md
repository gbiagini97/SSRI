# Organizzazione dati di tipo albero

## Alberi

### Alberi: specifiche

Definizione:
> Sia dato un insieme finito ed ordinato di elementi detti **nodi**.
> Se tale insieme non e' vuoto, allora un particolare nodo e' designato come **radice**, ed i rimanenti nodi, se esistono, sono a loro volta separati in insiemi ordinati disgiunti (**partizione dei nodi**).
> Una struttura cosi' costruita e' detta **albero ordinato**, o piu' semplicemente albero.

Esempio di **albero decisionale** per ordinare 3 numeri _a_, _b_ e _c_ (_a !=b != c_):

![M3_albero_decisionale](md_resources/M3_albero_decisionale.png)

Terminologia:
* Sia _T_ un albero di _n_ nodi di **radice** _r_;
* Se l'albero e' vuoto allora _T = Λ_;
* Siano _T<sub>1</sub>, ..., T<sub>k</sub> gli **insiemi disgiunti** non vuoti in cui sono partizionati i rimanenti _n -1_ nodi di _T_, aventi come radice i nodi _r<sub>1</sub>, ..., r<sub>k</sub>_;
* I nodi _r<sub>1</sub>, ..., r<sub>k</sub> sono detti anche **fratelli**;
* Ciascun _T<sub>i</sub> e' detto **sottoalbero** di _T_ mentre i nodi _r<sub>i</sub>_ sono detti **figli** di _r_, detto **padre**;
* Il generico nodo _u_ e' detto **foglia**;
* La radice e' l'unico nodo senza padre;
* Il **livello** di un nodo coincide con il numero di nodi che, ricorsivamente, sono i suoi padri.

Specifica sintattica:
* Operatori specifici del tipo di dato albero:
  * Operatori di creazione:
    * creaalbero: `() -> albero`;
  * Operatori di controllo:
    * foglia: `(nodo, albero) -> booleano`;
    * finefratelli: `(nodo, albero) -> booleano`;
  * Operatori di selezione:
    * radice: `(albero) -> nodo`;
    * padre: `(nodo, albero) -> nodo`;
    * primofiglio: `(nodo, albero) -> nodo`;
    * succfratello: `(nodo, albero) -> nodo`;
  * Operatori di interrogazione:
    * alberovuoto: `(albero) -> booleano`;
  * Operatori di modifica:
    * insradice: `(nodo, albero) -> albero`;
    * inssottoalbero: `(nodo, nodo, albero, albero) -> albero`;
    * cancsottoalbero: `(nodo, albero) -> albero`.

Specifica semantica:
* Operatori di creazione:
  * `creaalbero() = T'`
    * post: _T' = Λ_, albero vuoto
* Operatori di controllo:
  * `foglia(u, T) = b`
    * pre: _T != Λ_, _u_ nodo in _T_
    * post: _b = true_ se non esiste _v_ in _T_ tale che _u = padre(v, T)_; _b = false_ altrimenti
  * `finefratelli(u, T) = b`
    * pre: _T != Λ_, _u_ nodo in _T_ o _"sentintella" s_
    * post: _b = true_ se _u = s_; _b = false_ altrimenti
* Operatori di selezione:
  * `radice(T) = u`
    * pre: _T != Λ_
    * post: _u = r_
  * `padre(u, T) = v`
    * pre: _T != Λ_, _u_ nodo in _T_, _u != r_
    * post: _v_ padre di _u_ in _T_
  * `primofiglio(u, T) = v`
    * pre: _T != Λ_, _u_ nodo in _T_, _foglia(u, T) = false_
    * post: _v_ e' il primo figlio secondo la relazione di precedenza stabilita tra i figli di _u_
  * `succfratello(u, T) = v`
    * pre: _T != Λ_, _u_ nodo in _T_
    * post: _v_ nodo che segue _u_ nella relazione di precedenza (_v = s_ se _u_ e' l'ultimo fratello)
* Operatori di interrogazione:
  * `alberovuoto(T) = b`
    * post: _b = true_ se _T = Λ_; _b = false_ altrimenti
* Operatori di modifica:
  * `insradice(u, T) = T'`
    * pre: _T = Λ_
    * post: _T' = {u}_ con _u = r_, radice di _T_
  * `inssottoalbero(u, v, T, U) = T'`
    * pre: _T != Λ_, _U != Λ_, _u_ e _v_ nodi di _T_, _v_ figlio di _u_ oppure _v = u_
    * post: _T'_ ottenuto da _T_ aggiungendo _U_ come sottoalbero: 
      * Se _u != v_ la radice _z_ di _U_ diventa il nuovo fratello che segue _v_
      * Se _u = v_ la radice _z_ di _U_ dicenta il primo figlio di _u_
  * `cancsottoalbero(u, T) = T'`
    * pre: _T != Λ_, _u_ nodo in _T_
    * post: _T'_ ottenuto da _T_ eliminando il sottoalbero di radice _u_; _T = Λ_ se _u = r_