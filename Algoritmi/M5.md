# Organizzazione dati di tipo orizzontale

## Insiemi

### Specifica e realizzazioni

Definizione:
> Un inieme e' una collezione di elementi **distinti** ma dello **stesso tipo**.
> E' la struttura matematica fondamentale e puo' essere descritto in due modi:
> * Elencando tutti gli elementi: _X = {1, 2, 3}_;
> * Definendo una proprieta' che caratterizza tutti gli elementi: _X = {x ∈ N : 1 <= x <= 3}_.

Ci sono delle affinita' tra gli insiemi e le liste, ma anche delle differenze sostanziali:
* Gli elementi di un insieme non sono caratterizzati da una posizione realativa;
* Non sono ammesse puo' copie dello stesso elemento nel medesimo insieme.

Gli insiemi, in quanto strutture matematiche dispongono di operatori specifici:
* Appartenenza: _x ∈ A_;
* Non-appartenenza: _x ∉ A_;
* Inclusione stretta: _A ⊆ B_;
* Non-inclusione stretta: _A ⊈ B_;
* Inclusione: _A ⊂ B_;
* Non-inclusione: _A ⊄ B_;
* Unione: _A ⋃ B_;
* Intersezione: _A ⋂ B_;
* Differenza: _A − B_.

Specifica sintattica:
* creainsieme: `() -> insieme`;
* insiemevuoto: `(insieme) -> booleano`;
* appartiene: `(tipoelem, insieme) -> booleano`;
* unione: `(insieme, insieme) -> insieme`;
* intersezione: `(insieme, insieme) -> insieme`;
* differenza: `(insieme, insieme) -> insieme`;
* inserisci: `(tipoelem, insieme) -> insieme`;
* cancella: `(tipoelem, insieme) -> insieme`.

Specifica semantica:
* `creainsieme() = A`
  * post: _A = ∅_
* `insiemevuoto(A) = b`
  * post: _b = true_ solo se _A = ∅_
* `appartiene(x, A) = b`
  * post: _b = true_ solo se _x ∈ A_
* `unione(A, B) = C`
  * post: _C = A ⋃ B_
* `intersezione(A, B) = C`
  * post: _C = A ⋂ B_
* `differenza(A, B) = C`
  * post: _C = A − B_
* `inserisci(x, A) = A'`
  * post: _A' = A ⋃ {x}_; se _x ∈ A_ allora _A' == A_
* `cancella(x, A) = A'`
  * post: _A' = A \ {x}_; se _x ∉ A_ allora _A' == A_

#### Realizzazione con vettore booleano:
* Si suppone che gli elementi dell'insieme siano identificabili univocamente con i numeri compresi tra _0_ e _n - 1_;
* Un insieme _A_ allora puo' essere rappresentato con un vettore booleano di _n_ posizioni in un cui la _k-esima_ posizione e' _true_ (1) se _k ∈ A_, altrimenti _false_ (0);

Con questa rappresentazione:
* Gli operatori `appartiene`, `inserisci` e `cancella` hanno complessita' _O(1)_;
* Tutti gli altri operatori invece sono O(n);
* La realizzazione risulta efficace solo per **strutture statiche** ovvero non vengono usati operatori di tipo `unione`, ecc;
* In generale c'e' un grande spreco di memoria che rende questa rappresentazione poco efficiente.

#### Realizzazione con liste non ordinate:
* Con un struttura dinamica non c'e' spreco di memoria;
* Gli elementi dell'insieme possono essere di un tipo qualsiasi;
* Gli oprtatori `creainsieme` e `insiemevuoto` sono _O(1)_;
* Gli operatori `appartiene`, `inserisci` e `cancella` sono _O(n)_;
* Gli operatori `unione`, `intersezione` e `differenza` sono _O(nm)_.
* Si tratta dunque di un'implementazione poco efficiente.

#### Realizzazione con liste ordinate:
* Se sugli elementi dell'insieme e' definita una relazione di ordinamento totale (ad esempio "<="), l'insieme puo' essere rappresentato con una lista ordinata per valori crescenti degli elementi;
* Gli operatori _O(nm)_ con liste non ordinate, migliorano a _O(n+m)_ che risulta essere ottima in quanto il problema della fusione di due sequenze ordinate ha complessita' _Ω(n+m)_;
* Gli oepratori lineari non modificano pero' la loro complessita'.

___

### Programmare con gli insiemi

#### Problema 
Dato un vettore di _n_ posizioni a valori in 0 e 1, scrivere due procedure per convertire il vettore nel corrispondente insieme realizzato con una lista non ordinata e una lista ordinata, rispettivamente.

#### Complessita' del problema
* Dimensione dell'input:
  * Il numero minimo di operazioni che qualsiasi algoritmo deve fare e' quello di scandire l'intero vettore per determinare l'appartenenza degli elementi all'ineieme, quinid risulta _Ω(n)_;
* Eventi contabili:
  * Per creare l'insieme occorron almeno _n_ inserimenti, risulta quindi:
    * _Ω(n)_ con le liste non ordinate;
    * _Ω(n<sup>2</sup>)_ con le liste ordinate.


#### Realizzazione in C

```C
insieme * creainsieme(vettore *V, int n) {
    int i;
    insieme *A;

    creainsieme(A);

    for(i = 0; i < n; i++)
        if(V[i])
            /* L'implementazione dell'operatore inserisci determina la complessita' della procedura */
            inserisci(i, A);
    
    return(A);
}

/* Per liste non ordinate */
void inserisci(tipoelem x, insieme A) {
    inslista(x, primolista(A), A);
}

/* Per liste ordinate */
void inserisci(tipoelem x, insieme A) {
    posizione p = primolista(A);

    while(leggilista(p, A) < x && !finelista(succlista(p, A), A))
        p = succlista(p, A);
    
    inslista(x, p, A);
}
```

#### Osservazioni
L'operatore `inserisci` nel caso di liste non ordinate ha complessita' costante, mentre nel caso di liste ordinate ha complessita' lineare.

L'algoritmo risulta avere complessita' ottima in entrambi i casi:
  * _O(n)_ con le liste non ordinate;
  * _O(n<sup>2</sup>)_ con le liste ordinate.

___

### Mfset
L'Mfset e' una particolare realizzazione per il tipo di dato insieme e sta per **Merge-Find-Set**.

Definizione:
> L'Mfset rappresenta una partizione di un insieme finito in sottoinsiemi disguinti, dette **componenti** o **parti**.
> Le operazioni ammesse permettono di stabilire a quale componente appartiene un generico elemento e di unire due componenti distinte.

Specifica sintattica:
* creamfset: `(insieme) -> mfset`;
* trova: `(tipoelem, mfset) -> componente`;
* fondi: `(tipoelem, tipoelem, mfset) -> mfset`.

Specifica semantica:
* `creamfset(A) = S`
  * post: _S_ e' partizione di sottoinsiemi _C<sub>i</sub>_ con _i = 1, ..., n_ ed _n = | A |_ di _A_
* `trova(x, S) = C`
  * pre: _∃ i = 1, ..., n : x ∈ C<sub>i</sub>_
  * post: _C = C<sub>i</sub>_
* `fondi(x, y, S) = S'`
  * pre: _trova(x, S) != trova(y, S)_
  * post: _S'_ e' composto da _S_ meno le componenti che contengono _x_ e _y_ piu' una nuova componente creata unendo le componenti che contengono _x_ e _y_

In particolare l'Mfset:
* Non prevede la cancellazione e l'inserzione di elementi;
* L'unica inserzione e' quella in fase di creazione con l'operatore `creamfset`.
  
L'implementazione efficiente con operatori Mfset realizza ogni componente _C<sub>i</sub>_ come un albero.

![M5_mfset_alberi](md_resources/M5_mfset_alberi.png)

#### Complessita'

Per realizzare gli operatori ipotizziamo che sia possibile accedere direttamente ai nodi di ogni albero (o componente):
* L'operatore `trova` si realizza salendo i padri lungo un percorso da un generico nodo sino ad arrivare alla radice;
* L'operatore `fondi` si comporta in maniera analoga imponendo che una delle due radici divenga il nuovo figlio dell'altra.

Vediamo come entrambi gli operatori prevedono di risalire il cammino nodo-radice, dunque una misura di complessita' degli operatori e' data dal livello massimo delle foglie di ciascun albero.

Per ridurre il livello massimo delle foglie basta scegliere come radice di una "fondi" quella relativa alla componente con maggior numero di nodi, imponendo quindi che la radice dell'abero con minor numero di nodi divenga un nuovo figlio della radice di quello piu' grande.

In una sequenza di fusioni nelle quali un generico elemento _x_ puo' essere coinvolto, il livello di _x_ puo':
* **Non variare** se _x_ appartiene all'albero piu' grande;
* **Aumenta di 1** se _x_ appartiene all'albero piu' piccolo:
  * In particolare il numero di nodi della nuova componente ottenuta con "fondi" e' almeno il doppio di quelli dell'albero a cui apparteneva _x_.

Considerato che inizialmente ci sono _n = |A|_ componenti di un unico elemento, le componenti piu' piccole alle quali _x_ puo' appartenere e che saranno impegnate in una fusione, sono al piu' **_O(logn)_**.

Vediamo in un esempio quante volte, un generico nodo _x_, viene coinvolto in un `fondi` che alza il livello del nodo _x_.

![M5_mfset_fondi](md_resources/M5_mfset_fondi.png)

Considerato che inizialmente il generico elemento _x_ e' al livello _0_ e ad ogni fusione il livello delle foglie dell'albero piu' piccolo aumenta di _1_, allora il **livello del nodo _x_** risulta essere **_O(logn) nel caso pessimo_**.

Quindi la complessita' degli operatori `trova` e `fondi` e' _O(logn)_.

#### Realizzazione
Supponiamo che l'insieme sia formato dagli interi da _1 a n_ e che l'insieme _A_ denoti anche la sua cardinalita', quindi _A = n_.

La foresta di alberi che modella le componenti di un Mfset puo' essere **rappresentata con un unico vettore dei padri** in cui ciascun nodo, ogni volta che diventa radice, puntera' a se stesso.

Il vettore `dim` sara' utilizzato per mantenere le dimensioni di ogni singola componente individuata tramite il valore della propria radice.

```C
# define maxlung 100

typedef int tipoelem;
typedef tipoelem, insieme, componente, cardinalita;

typedef struct _mfset {
    tipoelem padre;
    cardinalita dim;
} mfset;

insieme A;
mfset S[maxlung];

void creamfset(insieme A, mfset *S) {
    tipoelem i;

    for(i = 0; i < A; i++) {
        S[i].padre = i;
        S[i].dim = 1;
    }
}

componente trova(tipoelem x, mfset *S) {
    componente y;

    if(S[x].padre == x)
        y =x;
    else
        y = trova(S[x].padre, S);

    return(y);
}

void fondi(tipoelem x, tipoelem y, mfset *S) {
    componente i = trova(x, S);
    componente j = trova(y, S);

    if(i != j) {
        if(S[i].dim < S[j].dim) {
            S[i].padre = j;
            S[i].dim += S[i].dim;
        } else {
            S[j].padre = i;
            S[i].dim += S[j].dim;
        }
    }
}
```

La **tecnica di compressione dei percorsi** e' uno strumento per ridurre la complessita' media: consiste nel rendere figlio della radice ogni nodo che viene incontrato da `trova` nel percorso di risalita dal generico nodo _x_ alla radice.

Il blocco `else` viene modificato:

```C
componente trova(tipoelem x, mfset *S) {
    componente y;

    if(S[x].padre == x)
        y =x;
    else
        y = S[x].padre = trova(S[x].padre, S);

    return(y);
}
```