# M3

## Principi della programmazione strutturata.
Rappresenta la naturale estensione dell'approccio top-down, con una scomposizione gerarchica del problema a sottoprogrammi con dettaglio crescente.
Nasce dall'esigenza di gestire la complessita' di un programma al crescere delle sue dimensioni.

Qualsiasi programma comprende due tipi di attivita':
* **Attivita' di processo**: dove vengono eseguiti i calcoli.
* **Attivita' di gestione**: dove si prendono le decisioni, si trasferisce il controllo ad un sottoprogramma (tramite salti), allocare e deallocare variabili.

**Modularita'**:
* Ogni modulo deve avere un ruolo ben specifico e realizzare una specifica funzionalita'.
* Ogni modulo dovrebbe essere visibile in una sola schermata.
* Ogni modulo non dovrebbe contenere piu' di 3 livelli di strutture di controllo annidate.
* Tutte le attivita' dentro un modulo dovrebbero essere eseguite nelle stesse condizioni.
* Ciascun modulo deve avere un punto di ingresso e uno d'uscita.
___

## Programmi di parsing
Problema:
> Dato un file in input contenente testo e supponendo una certa grammatica, verificare che il testo sia generato dalla grammatica. Trovare, inoltre, le regole della grammatica e le alternative che sono state usate durante la derivazione.

Questo processo e' chiamato **parsing** o **analisi sintattica**.

I parser non sono definiti a mano ma tramite dei **generatori di parser** che generano un parser a partire dalla descrizione della grammatica e dal codice associato (semanticamente) alle regole della grammatica.
Le funzionalita' del parser sono:
* Verificare che il flusso in ingresso (tastiera o file) sia valido.
* Convertire il flusso in una **Abstract Syntax Tree**(o parse tree).
* Agire se si trova in un pattern specificato nello stream (**analisi semantica**).
Fasi del parsing:
* **Scanner**: lettura del flusso e identificazione dei token.
* **Parser**: matching tra token e regole grammaticali, generando un albero.

**Metodi di parsing**:
* Top down parsing: reperire i token dal flusso uno alla volta e confrontarli con le regole grammaticali che si trovano in alto nell'albero.
* Bottom up parsing: il confronto avviene partendo dalle regole in basso nella grammatica.
___

## Analisi semantica di un linguaggio di programmazione
La semantica serve per determinare cosa fa un programma, arricchendo la grammatica non contestuale tramite:
* **Attributi**: associa simboli della grammatica con la possibilita' di prendere dei valori.
* **Regole semantiche**: sequenze di azioni semantiche.
* **Azioni semantiche**: azione in grado di assegare valori agli attributi.

**Semantica statica**:
* Un insieme di simboli X della grammatica viene associato ad un set di attributi A(X).
* Gli attributi **sintetizzati** usano le informazioni del parse tree risalendo verso l'alto:
  * Realizzano un flusso informativo ascendente nell'albero sintattico.
* Gli attributi **ereditati** usando le informazioni del parse tree discendendo verso il basso:
  * Realizzaino un flusso informativo discendente e laterale nell'albero sintattico.

Le grammatiche con attributi associano **attributi semantici** a **simboli sintattici** e **regole semantiche** a **regole sintattiche**.

**Semantica dinamica**:
Rappresenta quei casi in cui la semantica viene determinata in fase di esecuzione. Esistono diversi tipi di semantica dinamica, ma ne affronteremo solo uno.

Semantica **operazionale**: Structured Operational Semantics (SOS) - Definizione della semantica guidata dalla sintassi.
Vengono definite delle regole di transizione che specificano i passi di computazione per un **costrutto di transizione**, spiegando come si passa da una configurazione all'altra.
Configurazioni e relazioni di transizione costituiscono uno **schema di transizione**.

**Compilatore**
La sintassi e' espressa con la grammatica ma la semantica e' piu' difficile da esprimere.
Un compilatore genericamente trasforma un linguaggio in un altro lavorando a fasi:
* Front end: analisi lessicale che produce token, analizzati sintatticamente, e semantica.
* Back end: TODO

**Compiler compiler/Generatore di parser**
E' uno strumento che crea parser, interpreti e compilatori partendo da una descrizione formale del linguaggio di programmazione e della macchina.
Il testo in input puo' contenere la grammatica scritta in BNF o EBNF, definendo la sintassi del linguaggio.
Le azioni di **associazione semantica** avvengono dopo il controllo sintattico del parser (che rifiuta frasi non conformi alla grammatica).
___

## Paradigmi di programmazione
E' un modello concettuale che fornisce la struttura di un programma, ne esistono differenti tipi.

### Programmazione imperativa o funzionale
* Action oriented - la computazione e' vista come una sequenza di azioni.
* Un programma e' composto da istruzioni che realizzano trasformazioni di stato.
* Uno stato e' identificato da tutti i valori di un certo insieme di variabili ad un certo istante dell'esecuzione.
* L'assegnazione e' l'elemento fondamentale.

### Programmazione funzionale
Ha le sue redici nel **Lambda calculus**, inventato negli anni 30 da Church, dove un programma e' una funzione che viene valutata per ottenere un risultato.
Il principio cardine e': il valore di un'espressione dipende unicamente dai valori delle sue sotto-espressioni:
 * Gli assegnamenti non scono considerati dato che possono cambiare valori alle variabili.
 * I cambi di valore delle variabili durante la valutazione di un'espressione sono considerati dei **side-effect**.
 * La potenza del paradigma funzionale sta nell'uso diretto di **funzioni e ricorsioni**.
L'allocazione della memoria e' implicita: variabili allocate se servono e deallocate quando non vengono piu' usate (**garbage collection**).
Una funzione puo' essere il valore di un'espressione, passata come argomento, messa in struttura dati, restituita da come valore di ritorno da altre funzioni.

La **trasparenza referenziale** significa che un'espressione (dunque anche una funzione) puo' essere sostituita con il suo valore:
 * Per avere la trasparenza referenziale una funzione deve essere senza effetti collaterali e deve essere completamente funzionale.
  * Quando una funzione prende una o piu' funzioni di input e da come output una funzione si tratta di **high order functions**.

Funzionale vs Imperativa:
 * La programmazione funzionale non contempla effetti collaterali nelle funzioni.
  * I cambi di valore delle variabili e uscire dallo scope sono pero' effetti collaterali.
 * I valori nella programmazione funzionale non vengono calcolati per cambiare stato al programma ma costruendo nuovi stati, dunque non puo' dare luogo a bug al runtime.
 * Nella programmazione imperativa si puo' replicare il concetto di trasparenza referenziale passando un puntatore ad una funzione come parametro.

Nella programmazione funzionale un tipo consiste in un insieme di elementi chiamati valori assieme ad un set di funzioni chiamate operazioni. I metodi servono per definire dei valori strutturati (come liste, prodotti, funzioni).
* I valori sono considerati senza una struttura interna, dunque sono inizializzati con **tipi base**.
  * L'unica operazione definita e' quella di confronto per uguaglianza.
    * Il controllo dei tipi viene effettuato su due campi:
      * **Overloading**: quando un simbolo ha significati diversi a seconda del contesto.
      * **Coercion**: quando e' richiesto un casting implicito.
  * Il prodotto tra n tipi e' una tupla (n-upla) che ha come elementi le coppie ordinate degli n tipi.
    * Le **projection functions** servono ad estrarre i due elementi delle coppie ordinate.

* La lista e' una sequenza finita di elementi dello stesso tipo.
  * L'accesso all'elemento x della lista ritorna true se la lista e' vuota, altrimenti ritorna la lista.
* Le funzioni possono coprire tutto il dominio oppure parzialmente e prendono il nome di **applicazioni**.
  * **Innermost evaluation**: valuto i parametri dell'applicazione prima dell'esecuzione dell'applicazione.
  * **Outermost evaluation**: sostituisco i parametri nel corpo della funzione, dunque li valuto solo al momento dell'esecuzione dell'applicazione
    * Innermost vs Outermost evaluation: la soluzione ideale sarebbe riconoscere quali calcoli ho effettuato in passato, evitando di doverli rifare.
    * Una soluzione e' lo **short circuit** che fa uso dei seguenti costrutti:
      * andAlso: A andAlso B e' falsa quando A e' falso, e vera se A e B sono vere.
      * orElse: A orElse B e' vera se A e' falsa, e falsa se A e B sono false.
    * Un' occorrenza locale o bound di una variabile o di una funzinoe puo' essere istanziata con un altro nome senza cambiare il significato del programma.
  * Le funzioni **ricorsive** si dicono 
    * **Lineari** se un'attivazione di f(a) puo' dare luogo ad altre attivazioni di f(a):
      * **Winding**: iniziano le attivazioni.
      * **Unwinding**: le attivazioni rilasciano il controllo e si prosegue col flusso.
    * **Tail** se restituisce un valore (senza richiedere ricorsione) oppure il risultato di un'altra attivazione ricorsiva.


### Programmazione logica
I linguaggi possono essere:
* **Procedurali**: con istruzioni ch spiegano al computer come svolgere un compito.
* **Dichiarativi**: che espongono il problema senza dare istruzioni per svolgerlo.
La programmazione logica impone un approccio dichiarativo, dove occorre rappresentare minuziosamente le entita' in gioco e la relazione logiche tra di loro.
La risoluzione del problema equivale alla realizzazione di una dimostrazione per deduzione: si forniscono i **fatti**, le **regole** che compongono i fatti o risultati di altre regole.
La programmazione logica viene affiancata allo studio dei paradigmi del linguaggio Prolog.

### Programmazione orientata agli oggetti
La programmazione orientata agli oggetti lavora su due concetti principali:
* **Scomposizione** dei problemi in sottoproblemi.
* **Astrazione**
  * **Procedurale**: permette di concentrarsi su una sezione del codice alla volta.
  * **Modulare**: collezione di dati e procedure che agiscono sui dati, disposti attorno al codice che effettua azioni sui dati.
  * **Dei dati**: e' il tipo definito dal programmatore (stack, albero, etc.).
  * **Degli oggetti**: il paradigma padre di questa programmazione.

L'astazione richiede che il linguaggio permetta di nascondere delle informazioni per rendere il programma piu' semplice da leggere ed elaborare successivamente:
* **Supporto**: un linguaggio supporta uno stile di programmazione se lo stile puo' essere espresso, controllato ed implementato in modo efficiente.
* **Permesso**: un linguaggio permette uno stile di programmazione se posso arrivare a programmare in quello stile anche senza il completo supporto del linguaggio.

#### Astrazione procedurale
Nel momento in cui una procedura e' stata definita la sua implementazione puo' essere astratta. 
Viene dunque nascosto il corpo della procedura e viene esposta un'interfaccia con la quale posso interagire in altri momenti, senza entrare nel merito del dettaglio implementativo.

#### Astrazione modulare
Un modulo e' una collezione di dichiarazioni che includono variabili e procedure locali. Come nella programmazione procedurale, questo espone un'interfaccia (pubblica o privata, con logiche di accesso) e il suo corpo viene nascosto.

#### Astrazione degli oggetti
Il programma manipola dei tipi strutturati, con il nome di **classi**, che e' l'abbreviazione di classi di oggetti.
Un oggetto e' un entita' che vive a runtime con dei dati istanziati su cui le operazioni possono agire.

___

## I primi linguaggi - Linguaggi di basso livello
Il lingguaggio macchina e' una sequenza di bit e i primi linguaggi di programmazione coincidevano con l'insieme delle istruzioni eseguibili dall'hardware (dunque ogni CPU aveva il proprio linguaggio).
Il linguaggio assembly ha una codifica simbolica, anziche' binaria.
Ogni istruzione e' identificata da una sigla e le variabili sono rappresentate da nomi.
I programmi scritti in assembly necessitano di un programma assemblatore per tradurre le istruzioni del linguaggio in istruzioni macchina.

___

## Compilatori e interpreti
La macchina astratta per la quale e' scritto un programma ad alto livello viene implementata sulla macchina reale attraverso un traduttore.
Esistono 3 tipologie di traduttori:
* **Compilatore**: e' un programma che traduce un programma ad alto livello in un programma equivalente in linguaggio macchina.
  * Il codice controllato rispetto la sua grammatica.
  * La traduzione e' specifica per l'architettura hardware.
  * Il codice specifico tradotto viene assemblato e viene creato l'eseguibile tramite un **linker**.
  * L'esecuzione prevede il caricamento in memoria tramite un **loader**.

* **Interprete**: e' un programma che simula la macchina astratta sulla macchina concreta attraverso alcuni passi:
  * Verifica di correttezza sintattica.
  * Traduzione.
  * Esecuzione del codice scritto:
    * L'interprete rimane attivo durante l'esecuzione.
  * Esistono due tipi di interpreti:
    * **Machine interpreters**: simulano l'esecuzione di un programma compilato per una particolare architettura (interprete bytecode + JVM).
    * **Language interpreters**: simulano l'esecuzione scritto per un particolare set di istruzioni.
* **Traduttori ibridi**: i programmi vengono parzialmente compilati e interpretati:
  * Generano un linguaggio macchina che non e' fruibile direttamente dal processore, deve essere interpretato dalla JVM.
  * Sono indipendenti dal processore.


### Compilatori
Il compilatore e' un programma, a differenza di quelli Pascal e C che sono detti auto-compilanti perche' furono scritti negli stessi linguaggi.
Consentono ai programmatori di ignorare i dettagli machine-dependant della programmazione.

Gli obiettivi dei compilatori sono:
* Correttezza e Sicurezza
* Protezione della proprieta' intellettuale
* Efficienza
* Supportare l'espressivita' del linguaggio
* Offirere un ambiente di programmazione
* Consentono di sfruttare i dettagli architetturali a basso livello (pipelines, uso della cache, parallelismo, etc.)

Il compilatore esegue il suo lavoro in due fasi:
* **Analisi**: viene spezzato il sorgente e creata una rappresentazione intermedia del programma attraverso:
  * Analisi lessicale
  * Analisi sintattica
  * Analisi semantica
* **Sintesi**: viene creato, partendo dalla rappresentazione intermedia, il programma target equivalente attraverso:
  * Generatore di codice
  * Ottimizzatore

Tutte queste fasi fanno affidamento a due funzioni di base:
* **Symbol table**: registrazione degli identificatori usati e i loro attributi su una struttura dati: 
  * Durante l'analisi lessicale vengono mappate le entry della tabella.
  * Durante l'analisi semantica e la generazione del codice intermedio vengono definiti gli attributi e inseriti nei record della symbol table.
* **Error Handler**: in ogni fase possono capitare errori che devono essere gestiti:
  * Durante l'analisi lessicale si valuta se i token appartengono al linguaggio.
  * Durante l'analisi sintattica si valuta se le stringhe di tocken violano regole strutturali del linguaggio.
  * Durante l'analisi semantica si valuta se le strutture sintattiche hanno un significato valido per gli operatori coninvolti.

**Programmi a supporto**: 
* **Preprocessore**: genera l'input per il compilatore:
  * Processa le macro.
  * Include i file esterni.
  * Include librerie ed estensioni al linguaggio attraverso macro.
  * Controllo dei flussi attraverso macro specifiche.

* **Assemblatore**: alcuni compilatori generano codice assembler che viene passato ad un assemblatore per la generazione del codice macchina:
  * Primo passo: trovo tutti gli identificatori che puntano ad una locazione sullo storage e li inserisco nella symbol table.
  * Secondo passo: scansiono il codice e trasformo le operazioni in linguaggio macchina.

* **Loader e linker**: agisce sul codice associandolo ad un'area di memoria:
  * Il linker consente di associare piu' codici macchina in un unico programma, tenendo traccia anche dei riferimenti esterni.
  

**Classificazione di un compilatore**:
* **Numero di passi**: compilatori a singolo o piu' passi.
* **Ottimizzazione**: tempo, spazio e potenza dissipata.

* **Linguaggio prodotto**: 
  * **Pure machine code**: generato senza dipendere da un particolare sistema operativo o libreria di funzioni.
  * **Augmented machine code**: generato per un particolare set di istruzioni macchina/sistema operativo.
  * **Virtual machine code**: composto esclusivamente da codice virtuale che permette di generare codice indipendetemente dall'hardware.

* **Formato target prodotto**: 
  * **Assembly language**: viene prodotto file di testo con codice assembly, il che semplifica il debug e la comprensione del funzionamento del compilatore.
  * **Relocatable binray format**: il codice puo' essere generato in formato binario con riferimenti esterni e la tabella degli indirizzi (symbol table) non soggetti a vincoli. Il linker consente di aggiungere librerie di supporto compilate separatamente.
  * **Memory image**: il codice compilato puo' essere caricato in memoria e subito eseguito, spesso con librerie limitate. Il programma deve essere compilato ad ogni esecuzione.


### Analisi lessicale
Il codice sorgente viene letto carattere per carattere:
* Si controllano errori lessicali e se ne tiene traccia nell'error handling della riga.
* Vengono rimossi i commenti e le informazioni non necessarie.
* Vengono processate le direttive di compilazione (include, define, ecc).
* Vengono ritornati i **token** (gli elementi minimi del linguaggio: parole chiave, nomi di variabili, operatori).
* Vengono memorizzati gli identificatori nella symbol table assieme agli attributi rilevati.
* Il programma viene dunque implementato come un automa a stati finiti deterministico.

I tool necessari per questa analisi sono:
* Identificatori: usati come nomi per variabili e funzioni.
* Lessemi: strutture composte da contatore ed incremento.
* Keyword: identificano costrutti.
* Transition diagram: per riconoscere le espressioni regolari e ritornare gli attributi associati ai token.

Uno strumento per generare analizzatori lessicali molto famoso e' **Lex** che, tramite la definizione di specifiche, crea un programma C che se compilato produce appunto l'analizzatore lessicale.
Il linguaggio Lex prevede:
* **Parte dichiarativa**: con variabili, costanti e regex.
* **Parte di traduzione**: che consistono in regex e azioni associate che l'analizzatore deve compiere quando la regex viene matchata.
* **Procedure ausiliarie**: procedure richiste dalle azioni.i

### Analisi sintattica
Si esegue un controllo sintattico tramite una **Context Free Grammar** (spesso tramite BNF) per trovare l'albero sintattico del programma, cercando eventuali errori e raggruppando i token in frasi grammaticali.
Fa uso di un parser che riceve i token dallo scanner dell'analisi lessicale.

Il parser puo' lavorare in varie modalita':

**TopDown parsing**: analisi sintattica detta **predittiva** dato che la costruzione del parse tree inizia dalla radice e procede verso le foglie.
 * **Recursive Predictive Parsing**
 * **Non-recursive Predictive Parsing** (LL parsing: left to right, left most)

**BottomUp parsing**: viene detta **shift-reduce parsing** dato che la costruzione parte delle foglie e va verso la radice.
 * **Operator-Precedence Parsing** (LR parsing: left to right, right most): si parte dalla stringa target e si procede a ritroso per riduzioni verso il simbolo iniziale. Durante il parsing e' importante capire quando effettuare una riduzione o una produzione per proseguire nel parsing.

**Backtracking**: tecnica che prevede di enumerare tutte le soluzioni cercando quella che soddisfa i vincoli, molto complesso e lento.

**Recursive descent parsing**: puo' capitare di tornare su una decisione presa perche' questa non porta ad alcun risultato (backtracking).
Qualora esista una left-recursion potrebbe innestarsi un ciclo infinito.
(Grammatica left-recursive: ambiguita' che porta ad una scelta difficile da interpretare dal parser).

**Predictive parsing**: serve per evitare il backtranig, facendo un lookahead del simbolo seguente che disambigua le scelte possibili (raramente puo' accadere di imbattersi in disambiguita' anche con il lookahead).

### Analisi semantica
Si controlla il significato delle istruzioni del codice integrando l'analisi sintattica e appoggiandosi alla symbol table.
Vengono effettuati controlli statici (dichiarazioni multiple, divisioni per zero, ecc).
Le informazioni raccolte da questa analisi non possono essere rappresentate in un parse tree, perche' bisogna tenere conto degli attributi.
Si fa uso della **Syntax-directed Translation**, ossia si eseguono frammenti di codice secondo le regole definite dal parse tree.

### Generatore di codice intermedio
Traduce cio' che e' semanticamente corretto catturandone il significato a runtime.
L'esecuzione viene mappata da un **Abstract Syntax Tree** che e' una prima forma di Intermediate Representation (IR).
La traduzione avviene generando un **three-address code** che e' del codice a basso livello simile al linguaggio macchina, generabile da un Abstract Syntax Tree.

### Fase di sintesi
Il codice IR viene mappato dal traduttore nel codice macchina target tramite l'ausilio di un ottimizzatore che cerca di migliorare il codice tradotto.