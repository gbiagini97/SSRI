# Rappresentazione elettronica dell'informazione

## Necessita' di rappresentare l'informazione 

Le macchine hanno lo scopo di agevolare la vita dell'uomo mediate operazioni automatizzate.
L'automatica e' una scienza che si occupa di studiare e realizzare macchine in grado di trasformare materie prime in prodotti finiti senza l'intervento diretto dell'uomo.
L'informatica e' una branca dell'automatica dove le materie prime e i prodotti finiti sono dati e informazioni.


Una macchina automatica e' un oggetto in grado di modificare in modo autonomo il proprio stato agendo su una o piu' grandezze fisiche (posizione, peso, temperatura).
Una macchina informatica necessita di una grandezza fisica che possa essere modificata in modo automatico e rappresentare concetti astratti.

Per rappresentare le informazioni dobbiamo:
* Identificare l'informazione che vogliamo elaborare: **il rappresentato**.
* Scegliere una grandezza fisica per il rappresentato: **il rappresentate**.
* Definire una **corrispondenza** tra rappresentato e rappresentante.

Il rappresentato puo' essere qualsiasi informazione che richieda un'elaborazione automatica e da' un'informazione concettuale di un fenomeno fisico (velocita' di un'automobile, temperatura di un locale, ammontare di euro in un conto bancario).

Il rappresentante e' una grandezza fisica il cui comportamento e' noto e modificabile (di tipo meccanico per il tachimetro dell'automobile, termico per valutare la temperatura).

La scelta del rappresentante e' dunque una componente importante per poter accedere al dato e i rappresentanti elettrici sono tra i migliori canditati per dimensioni, velocita' e costi di realizzazione (in particolare quelli basati su silicio).

## Rappresentazione analogica dell'informazione

Esempio di corrispondenza tra rappresentato e rappresentante:
Come rappresentato prendiamo il valore numerico della temperatura di un locale: che sara' variabile tra due valori Tmin e Tmax.
Come rappresentate scegliamo la tensione elettrica tra due punti di un circuito: che sara' variabile tra due valori 0 e Vmax.
La corrispondenza piu' ovvia e' **biunivoca** e lineare (si dice analogica perche' abbiamo una completa analogia anche su piccole variazioni).

La rappresentazione analogica e':
* **Fedele**: in quanto piccole variazioni del rappresentato comportano piccole variazioni sul rappresentante.
* **Intuitiva**: poiche' dal rappresentate si risale immediatamente al rappresentato e le variazioni del rappresentate fanno capire immediatamente il comportamento del rappresentato.
* **Vulnerabile**: perche' ogni valore del rappresentante e' ammissibile dunque ogni variazione alla curva di corrispondenza dovuta a disturbi o invecchiamenti, genera errori di rappresentazione. Poiche' ogni rappresentazione e' intrinsecamente affetta da errori di approssimazione, qualora il rappresentante perda la corretta taratura la propagazione e la moltiplicazione dell'errore, quel rappresentante diventa poco affidabile o addirittura non significativo.

## Rappresentazione digitale dell'informazione

Nasce per eliminare la vulnerabilita' della rappresentazione analogica, evitando che qualsiasi valore sia ammissibile, tramite la scelta di un numero discreto di valori del rappresentante.

La corrispondenza tra rappresentato e rappresentante e' **univoca**:
* **Robusta**: una variazione del valore del rappresentate dovute a disturbi o invecchiamento vengono riconosciuti come **errori**.
* **Munita di autocorrezione**: se le variazioni del rappresentato sono sufficientemente piccole si puo' risalire ad un valore corretto del rappresentante.
* **Meno intuitiva**: ad un valore del rappresentato corrisponde un valore del rappresentato, ma non viceversa.
* **Poco fedele**: le variazioni di un rappresentato all'interno di un intervallo, non vengono rappresentate.

### Rappresentazione binaria

* **Estremamente robusta**: due sole cifre agli estremi del campo di variabilita' del rappresentate.
* **Autocorrezione molto semplice**: tramite arrotondamento.
* **Economica**: circuiti binari consumano molto poco, dunque e' possibile impiegarne molti in una singola applicazione.
* **Troppo limitata**: non e' possibile fare fede unicamente a due valori, serve un aumento di accuratezza. Impieghiamo dunque **piu' rappresentati** ad un rappresentato di modo che possano fornirci stringhe di bit (invece di un bit solo) e migliorare l'accuratezza in maniera esponenziale.


___

# Rappresentazione di informazioni con varie quantita' di bit

## Codifiche binarie di valori numerici

Tramite una rappresentazione di tipo binario possiamo rappresentare numeri, caratteri, matrici, forme d'onda.
Ci rifacciamo alla notazione decimale di tipo posizionale, dove ogni cifra ha un determinato **peso** dato dalla sua posizione nel numero. Nella notazione decimale il peso e' una potenza di 10 (base della notazione).
Anche le altre rappresentazioni, come quella binaria e quella esadecimale sono di tipo posizionale.

Per rappresentare una determinata informazione servono un numero di cifre:
> 0 <= n <= (base^c)-1
Dove **base** sta ad indicare il numero di cifre possibili per la determinata notazione (es. 10 per la notazione decimale, 2 per quella binaria, ecc) e **c** e' il numero di cifre che voglio impiegare per la rappresentazione.

Dunque per rappresentare un numero n ho bisogno di almeno:
> c = log(base10)n

Per quanto riguarda i **numeri frazionari** possiamo ricorrere anche alle potenze negative e porre una virgola anche nella rappresentazione binaria.
Per avere una buona precisione o estensione pero' serve una grande quantita' di bit.

Anche i numeri in **virgola mobile** vengono rappresentati mediante notazione esponenziale:
> n = m x b^e
**m** e' la mantissa costituita da cifre intere.
**b** e' la base (10, 2, 16 a seconda del tipo di notazione).
**e** e' l'esponente (positivo o negativo) da dare alla base per definire il peso delle cifre della mantissa. Serve dunque a muovere la posizone della virgola rispetto alle cifre della mantissa e consente di rappresentare valori molto piccoli o molto grandi.

Con i **numeri relativi** associamo un bit al segno (0 per i positivi, 1 per i negativi) e il resto dei bit al **modulo** del numero.