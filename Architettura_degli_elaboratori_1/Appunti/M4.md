# Struttura della CPU
___

## Struttura interna della CPU
___

### Data Path di una semplicissima CPU

Per analizzare in dettaglio la struttura interna di una CPU facciamo un esempio didattico con la CPU NS-0 (Nello Scarabottolo).

Caratteristiche:
* Macchina RISC: opcode da 2 bit, per un totale di 2^2=4 istruzioni;
  * Le istruzioni macchina non sono tutte di uguale lunghezza (una delle istruzioni usano due parole di memoria).
* Metodi di indirizzamento: solamente immediato e diretto;
* Macchina a 16bit: 
  * Data Bus a 16bit e dunque celle di memoria da 16 bit;
  * Address Bus a 14bit dunque 2^14=16K celle di spazio di indirizzamento.

Elementi interni:
* 1 registro GPR denominato R0;
* 1 registro di CC che puo' contenere solo il bit Z che ci dice se l'ultima operazione di somma da parte delle'ALU ha prodotto un risultato nullo;
* ALU che fa solo l'operazione di ADD;
* 1 Internal Bus di input che va verso i registri;
* 2 Internal Bus di output che vanno fuori dai registri.

Set di istruzioni:
* LOAD (opcode 00): porta nel registro R0 il contenuto della cella di memoria il cui indirizzo a 14bit e' contenuto nell'istruzione stessa;
* STORE (opcode 01): porta in memoria il contenuto di R0;
* ADD (opcode 10): occupa due parole di memoria:
  * La prima solo per indicare l'opcode 10;
  * La seconda per contenere una costante a 16 bit che sommata a R0 produce il risultato scritto su R0.
* BRZ (opcode 11): istruzione di salto per cui:
  * Se trova nel CC il bit Z a 1, forza l'indirizzo a 14 bit presente nell'istruzione nel PC.

Un registro della CPU NS-0 e' costituito da un certo numero di bistabili di tipo D, tanti quanti i bit del registro. 
Esiste un comando Rin che abilita tutti i bistabili e fa si cio' che e' presente nell'Internal Bus di input venga scritto nel registro. Ed esiste di riflesso un comando Rout1-2 (a seconda di quale Internal Bus di output va) che serve a abilitare/disabilitare i buffer TRI-STATE che contentono al contenuto del registro di essere emesso sul bus interno di destinazione, oppure di rimanere celato perche' le uscite sono ad alta impedenza.

Il registro di interfaccia al Data Bus esterno e' leggermente differente in quanto puo' ricevere le informazioni da campionare sia dall'Internal Bus in input sia dal Data Bus e puo' emettere le proprie informazioni sia sugli Internal Bus di output sia sul Data Bus.
Esistono in questo caso 4 comandi:
* MDRin: campiona nel registro MDR il contenuto dell'Internal Bus di input;
* MDRsample: campiona nel registro MDR cio' che compare nel Data Bus;
* MDRout1: emette nell'Internal Bus di output il contenuto del registro MDR;
* MDRoutenable: emette nel Data Bus esterno (verso i dispositivi Slave) il contenuto dei MDR.

Lo scopo degli Internal Bus e' quello di consentire ai registri di emettere il suo contenuto e di campionare il contenuto scritto.
Se l'ALU e' in grado di propagare cio' che si presenta ai suoi ingressi A o B in uscita O, questo consente di far circolare le informazioni tra i registri.

Vediamo quindi quali sono le istruzioni che l'ALU deve essere in grado di fare:
* **NOP** - comando 00: non chiediamo all'ALU di fare nulla;
* **PASS** - comando 01: funzione che consente all'ALU di prendere il contenuto del proprio ingresso A e propagarlo internamente in uscita (sull'Internal Bus di input);
* **INC** - comando 10: funzione di incremento che porta in output il valore dell'ingresso A aumentato di 1;
* **ADD** - comando 11: porta in uscita il risultato della somma dei due ingressi A e B e nel caso il risultato sia 0 porta 1 nella propria uscita di esito (**F**lag) di modo che i CC possano campionarlo.
  
Abbiamo definito dunque il **Data Path**, ossia il percorso di dati all'interno della CPU, che ci consente di muovere il contenuto dei vari registri e tramite MAR e MDR accedere anche informazioni presenti nei vari dispositivi Slave.

Per muovere i dati lungo il Data Path ci servono, oltre i comandi all'ALU, i comandi per i registri:
* **Zsample**: comando per campionare il valore di uscita di esito dell'ALU nel bit Z dei CC;
* **R0in, R0out1, R0out2**: comandi per consentire al contenuto del registro R0 di essere campionato oppure essere emesso sugli Internal Bus di output out1 e out2;
* **PCin, PCout1**: comandi per campionare il valore ed emettere il contenuto del Program Counter;
* **IRin, IRout1**: comandi per campionare il valore ed emettere il contenuto dell'Instruction Register;
* **MARin, MARoutenable**: comandi in entrata e in uscita verso gli Slave;
* **MDRin, MDRout1, MDRout2, MDRoutenable**: come il MAR puo' parlare anche agli Slave.

Includiamo anche i comandi **MEMread** e **MEMwrite** del Control Bus per accedere a memoria.

___

### Control Path di una semplicissima CPU

Col Data Path abbiamo visto come orchestrare i trasferimenti di dati nella CPU NS-0, vediamo ora come controllare tali trasferimenti mediante il Control Path.

Iniziamo dalla **fase di fetch** della prossima istruzione macchina e vediamo quale passo in sequenza deve essere fatto dalla CPU e quali comandi devono essere attivati:
* Passo 0: PCout1, ALUpass, MARin
  * Passiamo il valore del Program Counter nel registro di indirizzamanto, per consentire di indirizzare la cella di memoria contenente l'istruzione da acquisire;
* Passo 1: MARoutenable, MEMread, ALUnop
  * Emettiamo sull'Address Bus il contenuto nel MAR e dare alla memoria il comando di lettura (l'ALU non fa niente);
* Passo 2: MARoutenable, MEMread, MDRsample, ALUnop
  * Si conferma il comando precedente per dare il tempo alla memoria di trasmettere sul Data Bus il contenuto della cella indirizzata e con il comando MDRsample si fa in modo che questa istruzione da eseguire venga campionato nel MDR;
* Passo 3: MDRout1, ALUpass, IRin
  * Si trasferisce il contenuto del MDR nel registro istruzioni dove si potra' effettuare la decodifica;
* Passo 4: PCout1, ALUinc, PCin
  * Si intcrementa di 1 mediante l'ALU il contenuto del Program Counter per puntare all'istruzione macchina successiva (per far si' e' necessario che tutti i bistabili del registro PC siano Flip-Flop Master-Slave non trasparenti, in modo che il valore emesso in uscita e quello campionato in ingresso non si inseguano all'interno dei bistabili stessi).

Passiamo dunque alla **fase di decodifica**: in base all'opcode acquisito nella fase di fetch (che nella CPU NS-0 e' costituito dai 2 bit piu' significativi del registro IR) si decide quale tra le 4 istruzioni macchina deve essere eseguita.


**Fase di execution**.

Se l'istruzione decodificata e' la **LOAD**:
* Passo 5: IRout1, ALUpass, MARin
  * Portare i 14bit meno significativi dell'IR nel MAR in modo da poter indirizzare la cella da cui leggere il dato;
* Passo 6: MARoutenable, MEMread, ALUnop
* Passo 7: MARoutenable, MEMread, MDRsample, ALUnop
  * Lettura da memoria identica alla fase di fetch;
* Passo 8: MDRout1, ALUpass, ROin
  * Trasportare il contenuto del Memory Data Register in R0 che e' la destinazione del valore della cella letta.

Se l'istruzione decodificata e' la **STORE**:
* Passo 5: IRout1, ALUpass, MARin
  * Portare i 14bit meno significativi dell'IR nel MAR;
* Passo 6: R0out1, ALUpass, MDRin
  * Portare il contenuto di R0 nel Memory Data Register;
* Passo 7: MARoutenable, MEMwrite, MDRoutenable, ALUnop
  * Il MAR emette nell'Address Bus l'indirizzo da 14bit e contemporaneamente l'MDR emette nel Data Bus il dato da scrivere il memoria, dunque tramite il comando MEMwrite avviene la scrittura;
* Passo 8: MARoutenable, MEMwrite, MDRoutenable, ALUnop
  * Ripetere il passo una seconda volta per dare tempo al dispositivo di memoria di campionare il Data Bus e di scrivere tale valore nella cella indirizzata;

Se l'istruzione decodificata e' l'**ADD**:
* Passo 5: PCout1, ALUpass, MARin
* Passo 6: MARoutenable, MEMread, ALUnop
* Passo 7: MARoutenable, MEMread, MDRsample, ALUnop
* Passo 8: PCout1, ALUinc, PCin
  * La costante da sommare e' ancora presente in memoria, dobbiamo quindi ripetere una sorta di fase di fetch ovvero portare il PC nel registro di indirizzamento, fare una lettura da memoria, incrementare il PC per portarci alla prossima istruzione ed infine effettuare la somma vera e propria;
* Passo 9: MDRout1, R0out2, ALUadd, R0in, Zsample
  * Il registro MDR che e' la costante da sommare viene viene portato sul Internal Bus di output1, il contenuto di R0 va sul bus di output2, l'ALU somma i dati presenti ai suoi ingressi A e B e pone il risultato sull'Internal Bus di input e il registro CC campiona l'esito della somma per tenere traccia qualora il risultato fosse nullo.

Se l'istruzione decodificata e' **BRZ**:
* Passo 5: if(Z=1) IRout1, ALUpass, PCin
  * Se il registro CC ha il suo unico bit a 1 allora i 14bit di indirizzo presenti nel registro istruzioni mediante un passaggio verso l'ALU devono essere caricati nel Program Counter per saltare alla destinazione dell'istruzione di salto. Se nel CC c'e' 0, non si fa nulla e si procede con il fetch dell'istruzione successiva come da normale comportamento di salto condizionato dove la condizione non e' verificata.