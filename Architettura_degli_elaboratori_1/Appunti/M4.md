# Struttura della CPU
___

## Struttura interna della CPU
___

### Data Path di una semplicissima CPU

Per analizzare in dettaglio la struttura interna di una CPU facciamo un esempio didattico con la CPU NS-0 (Nello Scarabottolo).

Caratteristiche:
* Macchina RISC: opcode da 2 bit, per un totale di 2^2=4 istruzioni;
  * Le istruzioni macchina non sono tutte di uguale lunghezza (una delle istruzioni usano due parole di memoria).
* Metodi di indirizzamento: solamente immediato e diretto;
* Macchina a 16bit: 
  * Data Bus a 16bit e dunque celle di memoria da 16 bit;
  * Address Bus a 14bit dunque 2^14=16K celle di spazio di indirizzamento.

Elementi interni:
* 1 registro GPR denominato R0;
* 1 registro di CC che puo' contenere solo il bit Z che ci dice se l'ultima operazione di somma da parte delle'ALU ha prodotto un risultato nullo;
* ALU che fa solo l'operazione di ADD;
* 1 Internal Bus di input che va verso i registri;
* 2 Internal Bus di output che vanno fuori dai registri.

Set di istruzioni:
* LOAD (opcode 00): porta nel registro R0 il contenuto della cella di memoria il cui indirizzo a 14bit e' contenuto nell'istruzione stessa;
* STORE (opcode 01): porta in memoria il contenuto di R0;
* ADD (opcode 10): occupa due parole di memoria:
  * La prima solo per indicare l'opcode 10;
  * La seconda per contenere una costante a 16 bit che sommata a R0 produce il risultato scritto su R0.
* BRZ (opcode 11): istruzione di salto per cui:
  * Se trova nel CC il bit Z a 1, forza l'indirizzo a 14 bit presente nell'istruzione nel PC.

Un registro della CPU NS-0 e' costituito da un certo numero di bistabili di tipo D, tanti quanti i bit del registro. 
Esiste un comando Rin che abilita tutti i bistabili e fa si cio' che e' presente nell'Internal Bus di input venga scritto nel registro. Ed esiste di riflesso un comando Rout1-2 (a seconda di quale Internal Bus di output va) che serve a abilitare/disabilitare i buffer TRI-STATE che contentono al contenuto del registro di essere emesso sul bus interno di destinazione, oppure di rimanere celato perche' le uscite sono ad alta impedenza.

Il registro di interfaccia al Data Bus esterno e' leggermente differente in quanto puo' ricevere le informazioni da campionare sia dall'Internal Bus in input sia dal Data Bus e puo' emettere le proprie informazioni sia sugli Internal Bus di output sia sul Data Bus.
Esistono in questo caso 4 comandi:
* MDRin: campiona nel registro MDR il contenuto dell'Internal Bus di input;
* MDRsample: campiona nel registro MDR cio' che compare nel Data Bus;
* MDRout1: emette nell'Internal Bus di output il contenuto del registro MDR;
* MDRoutenable: emette nel Data Bus esterno (verso i dispositivi Slave) il contenuto dei MDR.

Lo scopo degli Internal Bus e' quello di consentire ai registri di emettere il suo contenuto e di campionare il contenuto scritto.
Se l'ALU e' in grado di propagare cio' che si presenta ai suoi ingressi A o B in uscita O, questo consente di far circolare le informazioni tra i registri.

Vediamo quindi quali sono le istruzioni che l'ALU deve essere in grado di fare:
* **NOP** - comando 00: non chiediamo all'ALU di fare nulla;
* **PASS** - comando 01: funzione che consente all'ALU di prendere il contenuto del proprio ingresso A e propagarlo internamente in uscita (sull'Internal Bus di input);
* **INC** - comando 10: funzione di incremento che porta in output il valore dell'ingresso A aumentato di 1;
* **ADD** - comando 11: porta in uscita il risultato della somma dei due ingressi A e B e nel caso il risultato sia 0 porta 1 nella propria uscita di esito (**F**lag) di modo che i CC possano campionarlo.
  
Abbiamo definito dunque il **Data Path**, ossia il percorso di dati all'interno della CPU, che ci consente di muovere il contenuto dei vari registri e tramite MAR e MDR accedere anche informazioni presenti nei vari dispositivi Slave.

Per muovere i dati lungo il Data Path ci servono, oltre i comandi all'ALU, i comandi per i registri:
* **Zsample**: comando per campionare il valore di uscita di esito dell'ALU nel bit Z dei CC;
* **R0in, R0out1, R0out2**: comandi per consentire al contenuto del registro R0 di essere campionato oppure essere emesso sugli Internal Bus di output out1 e out2;
* **PCin, PCout1**: comandi per campionare il valore ed emettere il contenuto del Program Counter;
* **IRin, IRout1**: comandi per campionare il valore ed emettere il contenuto dell'Instruction Register;
* **MARin, MARoutenable**: comandi in entrata e in uscita verso gli Slave;
* **MDRin, MDRout1, MDRout2, MDRoutenable**: come il MAR puo' parlare anche agli Slave.

Includiamo anche i comandi **MEMread** e **MEMwrite** del Control Bus per accedere a memoria.